# Server Documentation

## Overview

This document provides detailed documentation for the WebSocket server. The server is designed to facilitate real-time communication, acting as a signaling server for WebRTC peer-to-peer connections and as a hub for multi-user chat rooms.

The primary functionalities include:
-   Managing WebSocket connections from clients.
-   Broadcasting messages to clients within specific chat rooms.
-   Handling user presence and availability for WebRTC calls.
-   Matching users for WebRTC calls and assigning negotiation roles.
-   Relaying WebRTC signaling messages (offers, answers, ICE candidates) between peers.

This documentation is intended for developers and AI agents who need to interact with the server's API.

## API Endpoints

The server exposes two HTTP endpoints.

### Health Check

-   **Endpoint**: `GET /health`
-   **Description**: A simple health check endpoint to verify that the server is running.
-   **Success Response**:
    -   **Code**: `200 OK`
    -   **Content**: `{"status": "ok"}`

### WebSocket Upgrade

-   **Endpoint**: `GET /ws`
-   **Description**: This is the primary endpoint for establishing a WebSocket connection with the server. The connection must be upgraded from an HTTP GET request.
-   **Query Parameters**:
    -   `userId` (required): A unique identifier for the client. This ID is used for direct messaging and peer identification.
    -   `room` (optional): The name of the chat room the client wishes to join. If not provided, the client defaults to a room named "Lobby".
-   **Example Connection URL**:
    ```
    ws://<server-address>:8085/ws?userId=user123&room=my-chat-room
    ```

## WebSocket Message Structure

All communication over the WebSocket connection is done via JSON-formatted messages. Each message adheres to a generic structure, defined by the `Message` object.

```json
{
  "type": "message_type_here",
  "fromUser": "sender_client_id",
  "toUser": "recipient_client_id",
  "room": "chat_room_id",
  "payload": {},
  "messageId": "client_generated_uuid",
  "createTime": "2023-10-27T10:00:00Z",
  "incoming": true
}
```

### Fields

-   `type` (string, required): Defines the purpose of the message. The server uses this field to route the message to the correct handler. See the "Message Types" section for a full list of possible values.
-   `fromUser` (string, optional): The `userId` of the client sending the message. While optional in the client-sent message, the server will populate this field with the sender's connection ID before broadcasting or routing the message.
-   `toUser` (string, optional): The `userId` of the intended recipient. This is used for direct messaging, such as sending a WebRTC offer to a specific peer.
-   `room` (string, optional): The ID of the chat room. This is used for chat messages that should be broadcast to all members of a room.
-   `payload` (object, optional): A flexible JSON object containing the data specific to the message `type`. The structure of the payload varies depending on the message type.
-   `messageId` (string, optional): A unique identifier for the message, typically generated by the client (e.g., a UUID). This can be used for tracking messages.
-   `createTime` (string, optional): An ISO 8601 formatted timestamp indicating when the message was created. If not provided by the client, the server will add a timestamp.
-   `incoming` (boolean, optional): A client-side flag to indicate if a message is from a remote user. The server does not use this field.

## Message Types and Payloads

The `type` field in the message determines its purpose and the expected structure of its `payload`.

### Chat

#### `chat_message`

-   **Direction**: Client -> Server -> Client(s)
-   **Description**: Sends a text message to a chat room. The server broadcasts the message to all clients in the same room.
-   **Message Fields**:
    -   `room`: The target chat room.
-   **Payload (`ChatPayload`)**:
    ```json
    {
      "content": "Hello, world!"
    }
    ```

### Private Messaging

#### `private_message`

-   **Direction**: Client -> Server -> Client
-   **Description**: Sends a private text message to a specific user.
-   **Message Fields**:
    -   `toUser`: The `userId` of the recipient.
-   **Payload (`ChatPayload`)**:
    ```json
    {
      "content": "This is a private message."
    }
    ```

### User Presence

#### `get_user_list`

-   **Direction**: Client -> Server
-   **Description**: Requests the list of all currently connected users. The server will respond with an `update_user_list` message.
-   **Payload**: None.

#### `update_user_list`

-   **Direction**: Server -> Client
-   **Description**: Sent by the server to all clients whenever the list of connected users changes (a user connects or disconnects). It is also sent in response to a `get_user_list` request.
-   **Payload (`UserListPayload`)**:
    ```json
    {
      "users": ["user1", "user2", "user3"]
    }
    ```

### WebRTC Availability

#### `user_available_webrtc`

-   **Direction**: Client -> Server
-   **Description**: Notifies the server that the client is available to receive WebRTC call requests.
-   **Payload**: None.

#### `user_unavailable_webrtc`

-   **Direction**: Client -> Server
-   **Description**: Notifies the server that the client is no longer available for WebRTC calls (e.g., the user navigated away or closed the call interface).
-   **Payload**: None.

### Peer Matching

#### `request_random_peer`

-   **Direction**: Client -> Server
-   **Description**: The client requests to be matched with a random, available peer for a WebRTC call.
-   **Payload (`RequestRandomPeerPayload`)**:
    ```json
    {
      "currentPeerId": "previously_connected_peer_id" // Optional
    }
    ```
    - `currentPeerId`: If the user is skipping a peer they were just connected to, their ID can be included here to avoid immediate reconnection.

#### `assign_role`

-   **Direction**: Server -> Client
-   **Description**: Sent by the server to two matched peers. It assigns a role for the WebRTC negotiation process to avoid glare (simultaneous offer collision). One peer is "polite" (the callee) and the other is "impolite" (the caller).
-   **Message Fields**:
    -   `toUser`: The ID of the client receiving their role.
-   **Payload (`AssignRolePayload`)**:
    ```json
    {
      "role": "polite", // or "impolite"
      "peerId": "the_other_peer_id"
    }
    ```

#### `no_peer_available`

-   **Direction**: Server -> Client
-   **Description**: Sent to a client who requested a random peer when no other users are available.
-   **Payload**:
    ```json
    {
      "message": "No peer available at the moment. Please try again later."
    }
    ```

### WebRTC Signaling

These messages are relayed by the server between two specific peers (`fromUser` and `toUser`).

#### `webrtc_offer`

-   **Direction**: Client -> Server -> Client
-   **Description**: Sends a WebRTC session description offer to a peer.
-   **Message Fields**:
    -   `toUser`: The ID of the peer to receive the offer.
-   **Payload (`WebRTCSessionDescriptionPayload`)**:
    ```json
    {
      "type": "offer",
      "sdp": "session_description_protocol_string"
    }
    ```

#### `webrtc_answer`

-   **Direction**: Client -> Server -> Client
-   **Description**: Sends a WebRTC session description answer to a peer.
-   **Message Fields**:
    -   `toUser`: The ID of the peer to receive the answer.
-   **Payload (`WebRTCSessionDescriptionPayload`)**:
    ```json
    {
      "type": "answer",
      "sdp": "session_description_protocol_string"
    }
    ```

#### `webrtc_candidate`

-   **Direction**: Client -> Server -> Client
-   **Description**: Sends an ICE (Interactive Connectivity Establishment) candidate to a peer.
-   **Message Fields**:
    -   `toUser`: The ID of the peer to receive the candidate.
-   **Payload (`WebRTCIceCandidatePayload`)**:
    ```json
    {
      "candidate": { ... }, // The RTCIceCandidateInit object
      "sdpMid": "sdp_media_id", // Optional
      "sdpMLineIndex": 0, // Optional
      "usernameFragment": "fragment" // Optional
    }
    ```

### Error Handling

#### `error_response`

-   **Direction**: Server -> Client
-   **Description**: Sent by the server if it receives a malformed or invalid message from a client.
-   **Payload**:
    ```json
    {
      "error": "Invalid message structure",
      "details": "Description of the error"
    }
    ```

## WebRTC Signaling Flow

The following sequence describes how two clients (Peer A and Peer B) establish a WebRTC connection through the server.

1.  **Connection and Availability**
    -   Peer A connects to the WebSocket: `GET /ws?userId=peerA`
    -   Peer B connects to the WebSocket: `GET /ws?userId=peerB`
    -   Peer A sends a `user_available_webrtc` message to signal it's ready for calls.
    -   Peer B also sends a `user_available_webrtc` message.

2.  **Peer Matching**
    -   Peer A decides to start a call and sends a `request_random_peer` message.
    -   The server finds that Peer B is available. It removes both Peer A and Peer B from the available pool to prevent them from being matched with others.
    -   The server sends an `assign_role` message to Peer A with `{"role": "impolite", "peerId": "peerB"}`. The "impolite" peer is responsible for creating the WebRTC offer.
    -   The server sends an `assign_role` message to Peer B with `{"role": "polite", "peerId": "peerA"}`.

3.  **SDP Offer/Answer Exchange**
    -   Peer A (the "impolite" peer) creates an SDP offer.
    -   Peer A sends a `webrtc_offer` message with `toUser: "peerB"` and the SDP offer in the payload.
    -   The server relays this message to Peer B.
    -   Peer B receives the offer, sets its remote description, and creates an SDP answer.
    -   Peer B sends a `webrtc_answer` message with `toUser: "peerA"` and the SDP answer in the payload.
    -   The server relays this message to Peer A.
    -   Peer A receives the answer and sets its remote description. The basic connection is now established.

4.  **ICE Candidate Exchange**
    -   As Peer A and Peer B's ICE agents gather candidates (potential network paths), they send them to the other peer.
    -   Peer A's client generates an ICE candidate and sends a `webrtc_candidate` message with `toUser: "peerB"`.
    -   The server relays the candidate to Peer B, who adds it to its peer connection.
    -   Peer B's client generates an ICE candidate and sends a `webrtc_candidate` message with `toUser: "peerA"`.
    -   The server relays the candidate to Peer A, who adds it to its peer connection.
    -   This process repeats until both peers have exchanged enough candidates to find a suitable path for media to flow directly between them.

5.  **Call Termination**
    -   When the call ends, each client should clean up its local `RTCPeerConnection`.
    -   To become available for new calls, each client must send a `user_available_webrtc` message to the server again.

## Go Data Structures

This section provides documentation for the core data structures used in the Go server code, presented in a style similar to official Go documentation.

### type `Client`

```go
type Client struct {
    conn *websocket.Conn
    send chan []byte
    room string
    id   string
}
```

`Client` represents a single connected user. It holds the WebSocket connection, a buffered channel for outbound messages, and identifiers for the client and the room they are in.

-   `conn`: The underlying WebSocket connection.
-   `send`: A channel where JSON-formatted messages are placed to be sent to the client.
-   `room`: The ID of the chat room the client is currently in.
-   `id`: The unique `userId` for this client.

### type `Hub`

```go
type Hub struct {
    clients     map[*Client]bool
    clientsByID map[string]*Client
    broadcast   chan Message
    register    chan *Client
    unregister  chan *Client
    rooms       map[string]map[*Client]bool
    mu          sync.Mutex
}
```

`Hub` is the central component that manages all clients and message broadcasting.

-   `clients`: A set of all currently connected clients.
-   `clientsByID`: Maps `userId` strings to their corresponding `Client` pointers for direct access.
-   `broadcast`: A channel that receives messages from clients. The hub processes these messages.
-   `register`: A channel for new clients waiting to be registered.
-   `unregister`: A channel for clients that have disconnected and need to be cleaned up.
-   `rooms`: A map where keys are room IDs and values are sets of clients in that room.
-   `mu`: A mutex to synchronize access to shared resources like the client and room maps.

### type `Message`

```go
type Message struct {
    Type       string      `json:"type"`
    FromUser   string      `json:"fromUser,omitempty"`
    ToUser     string      `json:"toUser,omitempty"`
    Room       string      `json:"room,omitempty"`
    Payload    interface{} `json:"payload,omitempty"`
    MessageID  string      `json:"messageId,omitempty"`
    CreateTime string      `json:"createTime,omitempty"`
    Incoming   bool        `json:"incoming,omitempty"`
}
```

`Message` is the generic structure for all WebSocket messages exchanged between clients and the server. See the "WebSocket Message Structure" section for field details.

### Payload Structs

These structs define the `payload` for specific message types.

```go
// For "chat_message"
type ChatPayload struct {
    Content string `json:"content"`
}

// For "webrtc_offer" and "webrtc_answer"
type WebRTCSessionDescriptionPayload struct {
    Type string `json:"type"` // "offer" or "answer"
    Sdp  string `json:"sdp"`
}

// For "webrtc_candidate"
type WebRTCIceCandidatePayload struct {
    Candidate        interface{} `json:"candidate"`
    SdpMid           *string     `json:"sdpMid,omitempty"`
    SdpMLineIndex    *uint16     `json:"sdpMLineIndex,omitempty"`
    UsernameFragment *string     `json:"usernameFragment,omitempty"`
}

// For "assign_role"
type AssignRolePayload struct {
    Role   string `json:"role"`
    PeerId string `json:"peerId"`
}

// For "update_user_list"
type UserListPayload struct {
	Users []string `json:"users"`
}
```
